

		String 											StringBuffer									 	StringBulider

		String class is used to manipulate 				StringBuffer class is used to represent          	StringBulider/StringBuffer is only defferns is that all methods
		character strings that cannot be changed.		characters that can be modified					 	in StringBuffer are Syncornized but in case StringBulider methd is not
		
		Immutable										mutable												mutable
		
		Thread Safe										Thread-safe											Not Thread-safe
		
		JDK 1.0											JDK 1.5												JDK 1.5
		
		
		
Question : When to use String and StringBuffer?

Answer   :
			We know that String is immutable object. We can not change the value
			of a String object once it is initiated. If we try to change the value of
			the existing String object then it creates new object rather than changing
			the value of the existing object. So incase, we are going to do more
			modificatios on String, then use StringBuffer. StringBuffer updates the
			existing objects value, rather creating new object.


Question  : What is Immutable?
Answer    :  Immutable value/state that can not be changed once created
			 only one Thread can acces 
			 
Question  : How To Create Immutable class?		 
Answer    :			 
			 1) Don’t provide “setter” methods — methods that modify fields or objects referred to by fields.
				Setter methods are meant to change the state of object and this is what we want to prevent here.

			 2) Make all fields final and private
				This is another way to increase immutability. Fields declared private will not be accessible outside 
				the class and making them final will ensure the even accidentally you can not change them.

			 3) Don’t allow subclasses to override methods
			    The simplest way to do this is to declare the class as final. Final classes in java can not be overridden.

             4) Special attention when having mutable instance variables
				Always remember that your instance variables will be either mutable or immutable. 
				Identify them and return new objects with copied content for all mutable objects. 
				Immutable variables can be returned safely without extra effort.
				
				following are some Immutable Class
			a)	java.lang.String
			b)	java.lang.All Wrapper classes
			c)	java.lang.StackTraceElement 
			d)	java.io.File.
			e)	java.awt.Font
			f)	java.awt.Color

			
Question  : Why String is Immutable?
Answer    :
			1) Security : 
						Java class loading mechanism works on class names passed as parameters, then these classes are searched in class path. 
						Imagine for a minute, Strings were mutable, then anybody could have injected its own class-loading mechanism with 
						very little effort and destroyed or hacked in any application in a minute.
						
						ex. Class.forClass("jdbc:odbc:msqldriver")   
						
			2) Thread safety: 
							Immutable objects are safe when shared between multiple threads in multi-threaded applications. Just understand and learn it. 
							There is no super logic. If something can’t be changed, then even thread can not change it.
							
							As String class is main building block of java programming language, because of its use in class loading mechanism, 
							it was indeed a must use case to prevent the String class from being dirty in case of multiple thread. Immutability does 
							the magic here.
							
							
Question  : What is String  Pool?
Answer    :
			String pool is a special memory area separate from regular heap memory where these string constants are stored. 
			These objects are referred string variables during the life cycle of application.
			
			
			Case 1) =		String s1="abc";
						Above code causes JVM to verify if there is already a string “abc” (same char sequence). If such string exist, 
						JVM simply assign the reference of existing object to variable str, otherwise a new object “abc” will be created and 
						its reference will be assigned to variable str.
							 ---------------------
						  /--|		"abc"		 |
		String s1="abc";/ /--|-------------------|
	    String s2="abc";/	 |		"pqr"		 |
							 |-------------------|
							 |					 |
							 |-------------------|
							
			
			Case 2) New		String s1=new String("abc");
			
					This version end up creating two objects in memory. One object in string pool having char sequence “abc” 
					and second in heap memory referred by variable str and having same char sequence as “abc”.
			
			